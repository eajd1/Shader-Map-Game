// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Test

struct Pixel
{
    float height;
    uint details;
    float pressure;
    float temperature;
    float humitidy;
};

RWStructuredBuffer<Pixel> pixels;

int resolution; // Resolution of pixels (vertical)

int2 GetCoord(int2 coord, int2 offset)
// Calculates the coord with the offset
// Warning from unity: Integer modulus may be slower than unsigned
{
    int x = coord.x + offset.x;
    int y = coord.y + offset.y;

    x = x % (resolution * 2);
    if (x < 0) {
        x = (resolution * 2) + x;
    }

    // 2D map sphere wrapping the y is funny
    if (y < 0) {
        y = 0;

        if (x < resolution) {
            x = resolution + x;
        }
        else {
            x = x - resolution;
        }
    }
    else if (y > resolution - 1) {
        y = resolution - 1;

        if (x < resolution) {
            x = resolution + x;
        }
        else {
            x = x - resolution;
        }
    }

    return int2(x, y);
}

int GetPositonInBuffer(int2 coord) {
    return coord.x * resolution + coord.y;
}

[numthreads(1,1,1)]
void Test (uint3 id : SV_DispatchThreadID)
{
    int2 signedCoord = int2(id.x, id.y);

    //float height = 0;
    //height += pixels[GetPositonInBuffer(GetCoord(signedCoord, int2(-1, 0)))].height;
    //height += pixels[GetPositonInBuffer(GetCoord(signedCoord, int2(1, 0)))].height;
    //height += pixels[GetPositonInBuffer(GetCoord(signedCoord, int2(0, -1)))].height;
    //height += pixels[GetPositonInBuffer(GetCoord(signedCoord, int2(0, 1)))].height;
    //height /= 4;

    Pixel pixel = pixels[GetPositonInBuffer(signedCoord)];
    pixel.height = 1;
}
