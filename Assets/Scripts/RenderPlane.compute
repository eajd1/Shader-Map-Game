// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct Tile
{
    float height;
    int owner;
};

RWTexture2D<float4> Result;

RWStructuredBuffer<Tile> Tiles;
RWStructuredBuffer<float3> CountryColours;

int MapMode; // How to display the map

float Resolution; // resolution of heights
float DeepestPoint; // Deepest point in sea
float HighestPoint; // Highest point on land
float LowestPoint; // Lowest point on land
float CountryOpacity; // Opacity of the countries in country map mode

float2 CameraPosition; // -1 to 1 on x and y
float Zoom;


int2 GetCoord(int2 coord, int2 offset)
// Calculates the coord with the offset
{
    int x = coord.x + offset.x;
    int y = coord.y + offset.y;

    x = x % (uint)(Resolution * 2);
    if (x < 0)
        x = (Resolution * 2) + x;

    // 2D map sphere wrapping the y is funny
    if (y < 0)
    {
        y = 0;

        if (x < Resolution)
            x = Resolution + x;
        else
            x = x - Resolution;
    }
    else if (y > Resolution - 1)
    {
        y = Resolution - 1;

        if (x < Resolution)
            x = Resolution + x;
        else
            x = x - Resolution;
    }

    return int2(x, y);
}

int GetPositonInBuffer(int2 coord)
{
    return coord.x * Resolution + coord.y;
}

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint2 screenResolution = uint2(0, 0);
    Result.GetDimensions(screenResolution.x, screenResolution.y);
    float2 uv = (id.xy / (float2)screenResolution) * 2 - 1;
    uv *= Zoom;
    uv += CameraPosition;

    if (uv.x > 1)
        uv.x = -1 + (uv.x - 1);
    if (uv.x < -1)
        uv.x = 1 + (uv.x + 1);
    if (uv.y > 1 || uv.y < -1)
    {
        Result[id.xy] = float4(0.0, 0.0, 0.0, 1.0);
        return;
    }

    int2 coord = int2((uv.x + 1) / 2 * Resolution * 2, (uv.y + 1) / 2 * Resolution);

    float height = Tiles[GetPositonInBuffer(coord)].height;
    int countryID = Tiles[GetPositonInBuffer(coord)].owner;
    float3 countryColour = CountryColours[countryID];

    float3 terrainColour;
    if (height < 0) // Is ocean
        terrainColour = float3(0.0, 0.0, (1 - (height / DeepestPoint)));
    else if (height == 0)
        // Debug
        terrainColour = float3(0.0, 0.0, 0.0);
    else
        terrainColour = float3(0.0, sqrt(height / HighestPoint) * 0.8 + 0.2, 0.0);

    switch(MapMode)
    {
        case 0: // Terrain
            Result[id.xy] = float4(terrainColour, 1.0);
            break;

        case 1: // Ocean
            if (height < 0)
                Result[id.xy] = float4(1.0, 0.0, 0.0, 1.0);
            else
                Result[id.xy] = float4(0.0, 0.0, 0.0, 1.0);
            break;

        case 2: // Country
            if (countryID == 0)
            {
                Result[id.xy] = float4(terrainColour, 1.0);
                return;
            }

            Result[id.xy] = float4((1 - CountryOpacity) * countryColour + CountryOpacity * terrainColour, 1.0);
            break;

        case 3: //Borders
            if (countryID == 0)
            {
                Result[id.xy] = float4(terrainColour, 1.0);
                return;
            }

            int neighbourIds = 0;
            if (Tiles[GetPositonInBuffer(GetCoord(coord, int2(1, 0)))].owner == countryID)
                neighbourIds += 1;
            if (Tiles[GetPositonInBuffer(GetCoord(coord, int2(0, 1)))].owner == countryID)
                neighbourIds += 1;
            if (Tiles[GetPositonInBuffer(GetCoord(coord, int2(-1, 0)))].owner == countryID)
                neighbourIds += 1;
            if (Tiles[GetPositonInBuffer(GetCoord(coord, int2(0, -1)))].owner == countryID)
                neighbourIds += 1;

            if (neighbourIds < 4)
                Result[id.xy] = float4(countryColour, 1.0);
            else
                Result[id.xy] = float4(terrainColour, 1.0);
            break;
        
        case 4: //Simple Country
            if (height > 0)
                Result[id.xy] = float4(countryColour, 1.0);
            else
                Result[id.xy] = float4(terrainColour, 1.0);
            break;
    }
}
